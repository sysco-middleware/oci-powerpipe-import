/*
Copyright Â© 2024 NAME HERE <EMAIL ADDRESS>
*/
package cmd

import (
	"context"
	"database/sql"
	"encoding/csv"
	"github.com/spf13/cobra"
	"github.com/sysco-middleware/oci-powerpipe-import/db"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
)

// ociComplianceCmd represents the ociCompliance command
var ociComplianceCmd = &cobra.Command{
	Use:   "ociCompliance",
	Short: "imports powerpipe oci compliance report",
	Long: `Only support imports of the reports generated by turbot/oci_compliance mod. 
Currently we only support imports of the reports generated in csv format.

Flags marked as * are required`,
	RunE: func(cmd *cobra.Command, args []string) error {
		var p int
		var err error
		var ff, hh, uu, ss, pp string
		// check if the flag are provided
		if ff, err = cmd.Flags().GetString(importFilePath); err != nil {
			return err
		}
		if p, err = cmd.Flags().GetInt(dbPort); err != nil {
			return err
		}
		if hh, err = cmd.Flags().GetString(dbHost); err != nil {
			return err
		}
		if uu, err = cmd.Flags().GetString(dbUser); err != nil {
			return err
		}
		if ss, err = cmd.Flags().GetString(dbService); err != nil {
			return err
		}
		if pp, err = cmd.Flags().GetString(dbPass); err != nil {
			return err
		}

		// check if p is a valid file path
		if err = fileExists(ff); err != nil {
			return err
		}

		service, s, err := db.New(uu, pp, ss, hh, p)
		if err != nil {
			log.Printf("Failed to connect to database. missing property %s", s)
			return err
		}

		ctx := context.Background()
		id, err := service.GetRunID(ctx)
		if err != nil {
			log.Fatalf("msg: error.getting.run.id , err : %v \n", err)
		}

		log.Printf("id is %d \n", id)

		records, err := parseCsv(ff, id)
		if err != nil {
			log.Fatalf("msg: error.parsing.csv , err : %v \n", err)
		}

		err = service.BulkInsert(ctx, records)
		if err != nil {
			log.Fatalf("msg: error.inserting.bulk.records , err : %v \n", err)
		}

		log.Println("data imported")
		return nil
	},
}

func init() {

	rootCmd.AddCommand(ociComplianceCmd)
}

func fileExists(filename string) error {
	if _, err := os.Stat(filename); err != nil {
		return err
	}
	return nil
}

func parseCsv(filepath string, runID int64) ([]db.Report, error) {

	file, err := os.Open(filepath)
	if err != nil {
		return nil, err
	}

	defer file.Close()

	reader := csv.NewReader(file)

	var records []db.Report
	for {

		record, err := reader.Read()
		// if we've reached the end of the file, break
		if err == io.EOF {
			break
		}

		if err != nil {
			return nil, err
		}

		records = append(records, db.Report{
			RunID:              runID,
			GroupID:            record[0],
			Title:              record[1],
			Description:        parseSqlString(record[2]),
			ControlID:          record[3],
			ControlTitle:       record[4],
			ControlDescription: record[5],
			Reason:             record[6],
			Resource:           record[7],
			Status:             record[8],
			Severity:           parseSqlString(record[9]),
			Compartment:        parseSqlString(record[10]),
			Name:               parseSqlString(record[11]),
			Region:             parseSqlString(record[12]),
			ReportingRegion:    parseSqlString(record[13]),
			Tenant:             record[14],
			Category:           record[15],
			Cis:                parseBoolean(record[16]),
			CisItemID:          parseFloat(record[17]),
			CisLevel:           parseInt(record[18]),
			CisSectionID:       parseInt(record[19]),
			CisType:            record[20],
			CisVersion:         record[21],
			Plugin:             record[22],
			Service:            record[23],
			Type:               parseSqlString(record[24]),
			Created:            time.Now(),
		})
	}

	return records[1:], nil

}

func parseSqlString(str string) sql.NullString {
	ss := sql.NullString{}
	err := ss.Scan(str)
	if err != nil {
		return sql.NullString{}
	}
	return ss
}

func parseBoolean(str string) bool {
	if strings.TrimSpace(str) == "true" {
		return true
	}
	return false
}

func parseFloat(str string) float64 {
	ff, err := strconv.ParseFloat(str, 64)
	if err != nil {
		return 0.0
	}
	return ff
}
func parseInt(str string) int64 {
	i, err := strconv.ParseInt(str, 10, 64)
	if err != nil {
		return 0
	}
	return i
}
